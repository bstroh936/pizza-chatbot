{"ast":null,"code":"import userSchema from'./userSchema';import textSchema from'./textSchema';import optionsSchema from'./optionsSchema';import customSchema from'./customSchema';import updateSchema from'./updateSchema';import{stringify}from'flatted/cjs';var schema={parse:function parse(step){var parser=[];if(step.user){parser=userSchema;}else if(step.message){parser=textSchema;}else if(step.options){parser=optionsSchema;}else if(step.component){parser=customSchema;}else if(step.update){parser=updateSchema;}else{throw new Error(\"The step \".concat(stringify(step),\" is invalid\"));}for(var i=0,len=parser.length;i<len;i+=1){var _parser$i=parser[i],key=_parser$i.key,types=_parser$i.types,required=_parser$i.required;if(!step[key]&&required){throw new Error(\"Key '\".concat(key,\"' is required in step \").concat(stringify(step)));}else if(step[key]){if(types[0]!=='any'&&types.indexOf(typeof step[key])<0){throw new Error(\"The type of '\".concat(key,\"' value must be \").concat(types.join(' or '),\" instead of \").concat(typeof step[key]));}}}var keys=parser.map(function(p){return p.key;});for(var _key in step){if(keys.indexOf(_key)<0){console.error(\"Invalid key '\".concat(_key,\"' in step '\").concat(step.id,\"'\"));delete step[_key];}}return step;},checkInvalidIds:function checkInvalidIds(steps){for(var key in steps){var step=steps[key];var triggerId=steps[key].trigger;if(typeof triggerId!=='function'){if(step.options){var triggers=step.options.filter(function(option){return typeof option.trigger!=='function';});var optionsTriggerIds=triggers.map(function(option){return option.trigger;});for(var i=0,len=optionsTriggerIds.length;i<len;i+=1){var optionTriggerId=optionsTriggerIds[i];if(optionTriggerId&&!steps[optionTriggerId]){throw new Error(\"The id '\".concat(optionTriggerId,\"' triggered by option \").concat(i+1,\" in step '\").concat(steps[key].id,\"' does not exist\"));}}}else if(triggerId&&!steps[triggerId]){throw new Error(\"The id '\".concat(triggerId,\"' triggered by step '\").concat(steps[key].id,\"' does not exist\"));}}}}};export default schema;","map":{"version":3,"sources":["C:/Users/TheTOP/Documents/GitHub/pizza-chatbot-chk4/src/components/chatbot/schemas/schema.js"],"names":["userSchema","textSchema","optionsSchema","customSchema","updateSchema","stringify","schema","parse","step","parser","user","message","options","component","update","Error","i","len","length","key","types","required","indexOf","join","keys","map","p","console","error","id","checkInvalidIds","steps","triggerId","trigger","triggers","filter","option","optionsTriggerIds","optionTriggerId"],"mappings":"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","sourcesContent":["import userSchema from './userSchema';\nimport textSchema from './textSchema';\nimport optionsSchema from './optionsSchema';\nimport customSchema from './customSchema';\nimport updateSchema from './updateSchema';\nimport { stringify } from 'flatted/cjs';\n\nconst schema = {\n  parse(step) {\n    let parser = [];\n\n    if (step.user) {\n      parser = userSchema;\n    } else if (step.message) {\n      parser = textSchema;\n    } else if (step.options) {\n      parser = optionsSchema;\n    } else if (step.component) {\n      parser = customSchema;\n    } else if (step.update) {\n      parser = updateSchema;\n    } else {\n      throw new Error(`The step ${stringify(step)} is invalid`);\n    }\n\n    for (let i = 0, len = parser.length; i < len; i += 1) {\n      const { key, types, required } = parser[i];\n\n      if (!step[key] && required) {\n        throw new Error(`Key '${key}' is required in step ${stringify(step)}`);\n      } else if (step[key]) {\n        if (types[0] !== 'any' && types.indexOf(typeof step[key]) < 0) {\n          throw new Error(\n            `The type of '${key}' value must be ${types.join(' or ')} instead of ${typeof step[\n              key\n            ]}`\n          );\n        }\n      }\n    }\n\n    const keys = parser.map(p => p.key);\n\n    for (const key in step) {\n      if (keys.indexOf(key) < 0) {\n        console.error(`Invalid key '${key}' in step '${step.id}'`);\n        delete step[key];\n      }\n    }\n\n    return step;\n  },\n\n  checkInvalidIds(steps) {\n    for (const key in steps) {\n      const step = steps[key];\n      const triggerId = steps[key].trigger;\n\n      if (typeof triggerId !== 'function') {\n        if (step.options) {\n          const triggers = step.options.filter(option => typeof option.trigger !== 'function');\n          const optionsTriggerIds = triggers.map(option => option.trigger);\n\n          for (let i = 0, len = optionsTriggerIds.length; i < len; i += 1) {\n            const optionTriggerId = optionsTriggerIds[i];\n            if (optionTriggerId && !steps[optionTriggerId]) {\n              throw new Error(\n                `The id '${optionTriggerId}' triggered by option ${i + 1} in step '${\n                  steps[key].id\n                }' does not exist`\n              );\n            }\n          }\n        } else if (triggerId && !steps[triggerId]) {\n          throw new Error(\n            `The id '${triggerId}' triggered by step '${steps[key].id}' does not exist`\n          );\n        }\n      }\n    }\n  }\n};\n\nexport default schema;\n"]},"metadata":{},"sourceType":"module"}