{"ast":null,"code":"var codesUS = require('./codes'),\n    states = require('./states'),\n    codesCanada = require('./codesCanada');\n\nvar codes = {};\ncodes.codes = Object.assign({}, codesUS.codes, codesCanada.codes);\ncodes.stateMap = Object.assign({}, codesUS.stateMap, codesCanada.stateMap);\nexports.states = states;\nexports.codes = codes.codes;\n\nvar lookup = function lookup(zip) {\n  if (zip != null && zip != undefined && typeof zip === \"string\" && isNaN(zip.charAt(0))) {\n    return codes.codes[zip.slice(0, 3)];\n  }\n\n  return codes.codes[zip];\n};\n\nexports.lookup = lookup;\n\nvar random = function random() {\n  var keys = Object.keys(codes.codes);\n  return codes.codes[keys[keys.length * Math.random() << 0]];\n};\n\nexports.random = random;\n\nvar byName = function byName(city, state) {\n  city = city.toUpperCase();\n  var ret = [];\n  byState(state).forEach(function (item) {\n    if (city === item.city.toUpperCase()) {\n      ret.push(item);\n    }\n  });\n  return ret;\n};\n\nexports.lookupByName = byName;\n\nvar byState = function byState(state) {\n  var normalized = states.normalize(state.toUpperCase()),\n      ret = [],\n      mapping = codes.stateMap[normalized] || codes.stateMap[state];\n\n  if (!mapping) {\n    return ret;\n  }\n\n  mapping.forEach(function (zip) {\n    ret.push(codes.codes[zip]);\n  });\n  return ret;\n};\n\nexports.lookupByState = byState;\n\nvar dist = function dist(zipA, zipB) {\n  zipA = lookup(zipA);\n  zipB = lookup(zipB);\n\n  if (!zipA || !zipB) {\n    return null;\n  }\n\n  var zipALatitudeRadians = deg2rad(zipA.latitude);\n  var zipBLatitudeRadians = deg2rad(zipB.latitude);\n  var distance = Math.sin(zipALatitudeRadians) * Math.sin(zipBLatitudeRadians) + Math.cos(zipALatitudeRadians) * Math.cos(zipBLatitudeRadians) * Math.cos(deg2rad(zipA.longitude - zipB.longitude));\n  distance = Math.acos(distance) * 3958.56540656;\n  return Math.round(distance);\n};\n\nexports.distance = dist; //This is SLLOOOOWWWWW\n\nexports.radius = function (zip, miles, full) {\n  var ret = [],\n      i,\n      d; // Validate zip before scanning\n\n  if (!lookup(zip)) return [];\n\n  for (i in codes.codes) {\n    if (dist(zip, i) <= miles) {\n      ret.push(full ? codes.codes[i] : i);\n    }\n  }\n\n  return ret;\n};\n\nvar deg2rad = function deg2rad(value) {\n  return value * 0.017453292519943295;\n};\n\nexports.toMiles = function (kilos) {\n  return Math.round(kilos / 1.609344);\n};\n\nexports.toKilometers = function (miles) {\n  return Math.round(miles * 1.609344);\n};\n\nfunction haversine(lat1, lon1, lat2, lon2) {\n  // Retuns the great circle distance between two coordinate points in miles\n  var dLat = deg2rad(lat2 - lat1);\n  var dLon = deg2rad(lon2 - lon1);\n  var lat1 = deg2rad(lat1);\n  var lat2 = deg2rad(lat2);\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return 3960 * c;\n}\n\nfunction lookupByCoords(lat, lon) {\n  // Return the closest code to coordinates at lat,lon\n  var minDist = Infinity;\n  var minCode = null;\n\n  for (zip in codes.codes) {\n    var code = codes.codes[zip];\n\n    if (code.latitude && code.longitude) {\n      var dist = haversine(lat, lon, code.latitude, code.longitude);\n\n      if (dist < minDist) {\n        minDist = dist;\n        minCode = code;\n      }\n    }\n  }\n\n  return minCode;\n}\n\nexports.lookupByCoords = lookupByCoords;","map":{"version":3,"sources":["C:/Users/TheTOP/Documents/GitHub/pizza-chatbot-chk4/node_modules/zipcodes/lib/index.js"],"names":["codesUS","require","states","codesCanada","codes","Object","assign","stateMap","exports","lookup","zip","undefined","isNaN","charAt","slice","random","keys","length","Math","byName","city","state","toUpperCase","ret","byState","forEach","item","push","lookupByName","normalized","normalize","mapping","lookupByState","dist","zipA","zipB","zipALatitudeRadians","deg2rad","latitude","zipBLatitudeRadians","distance","sin","cos","longitude","acos","round","radius","miles","full","i","d","value","toMiles","kilos","toKilometers","haversine","lat1","lon1","lat2","lon2","dLat","dLon","a","c","atan2","sqrt","lookupByCoords","lat","lon","minDist","Infinity","minCode","code"],"mappings":"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","sourcesContent":["\r\nvar codesUS = require('./codes'),\r\n    states = require('./states'),\r\n    codesCanada = require('./codesCanada');\r\n\r\nvar codes = {};\r\ncodes.codes = Object.assign({}, codesUS.codes, codesCanada.codes);\r\ncodes.stateMap = Object.assign({}, codesUS.stateMap, codesCanada.stateMap);\r\n\r\nexports.states = states;\r\nexports.codes = codes.codes;\r\n\r\nvar lookup = function(zip) {\r\n    if (zip != null && zip != undefined && typeof zip === \"string\" && isNaN(zip.charAt(0))) {\r\n      return codes.codes[zip.slice(0, 3)];\r\n    }\r\n    return codes.codes[zip];\r\n};\r\n\r\nexports.lookup = lookup;\r\n\r\nvar random = function() {\r\n    var keys = Object.keys(codes.codes)\r\n    return codes.codes[keys[ keys.length * Math.random() << 0]];\r\n};\r\nexports.random = random;\r\n\r\nvar byName = function(city, state) {\r\n    city = city.toUpperCase();\r\n\r\n    var ret = [];\r\n    \r\n    byState(state).forEach(function(item) {\r\n        if (city === item.city.toUpperCase()) {\r\n            ret.push(item);\r\n        }\r\n    });\r\n\r\n    return ret;\r\n};\r\n\r\nexports.lookupByName = byName;\r\n\r\nvar byState = function(state) {\r\n    var normalized = states.normalize(state.toUpperCase()),\r\n        ret = [],\r\n        mapping = codes.stateMap[normalized] || codes.stateMap[state];\r\n\r\n    if (!mapping) {\r\n        return ret;\r\n    }\r\n\r\n    mapping.forEach(function(zip) {\r\n        ret.push(codes.codes[zip]);\r\n    });\r\n\r\n    return ret;\r\n};\r\n\r\nexports.lookupByState = byState;\r\n\r\nvar dist = function(zipA, zipB) {\r\n    zipA = lookup(zipA);\r\n    zipB = lookup(zipB);\r\n    if (!zipA || !zipB) {\r\n        return null;\r\n    }\r\n    \r\n    var zipALatitudeRadians = deg2rad(zipA.latitude);\r\n    var zipBLatitudeRadians = deg2rad(zipB.latitude);\r\n\r\n    var distance = Math.sin(zipALatitudeRadians) \r\n                * Math.sin(zipBLatitudeRadians) \r\n                + Math.cos(zipALatitudeRadians) \r\n                * Math.cos(zipBLatitudeRadians) \r\n                * Math.cos(deg2rad(zipA.longitude - zipB.longitude)); \r\n\r\n    distance = Math.acos(distance) * 3958.56540656;\r\n    return Math.round(distance);\r\n};\r\n\r\nexports.distance = dist;\r\n\r\n\r\n//This is SLLOOOOWWWWW\r\nexports.radius = function(zip, miles, full) {\r\n    var ret = [], i, d;\r\n    // Validate zip before scanning\r\n    if (!lookup(zip))\r\n        return [];\r\n    for (i in codes.codes) {\r\n        if (dist(zip, i) <= miles) {\r\n            ret.push(((full) ? codes.codes[i] : i));\r\n        }\r\n    }\r\n\r\n    return ret;\r\n};\r\n\r\n\r\nvar deg2rad = function(value) {\r\n    return value * 0.017453292519943295;\r\n};\r\n\r\nexports.toMiles = function(kilos) {\r\n    return Math.round(kilos / 1.609344);\r\n};\r\n\r\nexports.toKilometers = function(miles) {\r\n    return Math.round(miles * 1.609344);\r\n};\r\n\r\n\r\nfunction haversine(lat1,lon1, lat2,lon2) {\t\t// Retuns the great circle distance between two coordinate points in miles\r\n\tvar dLat = deg2rad(lat2 - lat1);\r\n\tvar dLon = deg2rad(lon2 - lon1);\r\n\tvar lat1 = deg2rad(lat1);\r\n\tvar lat2 = deg2rad(lat2);\r\n\r\n\tvar a = Math.sin(dLat/2) * Math.sin(dLat/2) +\r\n\t\t\tMath.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);\r\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n\treturn 3960 * c;\r\n}\r\n\r\nfunction lookupByCoords(lat,lon) {\t\t\t\t// Return the closest code to coordinates at lat,lon\r\n\tvar minDist = Infinity;\r\n\tvar minCode = null;\r\n\r\n\tfor(zip in codes.codes) {\r\n\t\tvar code = codes.codes[zip];\r\n\t\tif(code.latitude && code.longitude) {\r\n\t\t\tvar dist = haversine(lat,lon, code.latitude, code.longitude);\r\n\t\t\tif(dist<minDist) {\r\n\t\t\t\tminDist = dist;\r\n\t\t\t\tminCode = code;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn minCode;\r\n}\r\n\r\nexports.lookupByCoords = lookupByCoords;\r\n"]},"metadata":{},"sourceType":"script"}